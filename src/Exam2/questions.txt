
=============================================================================== FROM BOOK =========================================================================
corrects: 10/128
wrongs: 3/128

1. Heritage
My Answer: D
Obs: i've answered right, because the Bread tries overwrite a final method.

2. FileReader, skip method
My Answer: A
Obs: i've answered right, because there is no issues and the result is based on result from skip() method

3. Encapsulation
My Answer: D
Obs: Correct, Because one of the principals of encapsulation is there is private variables.

4. Increase with <variable>++
My Answer: A
Obs: Correct, Because the i++ has done before the print the value.

5. Switch-Case
My: C
Obs: Correct, after do the replacements the next index does not exist so an exception is throws.

6. Extends and Implements
My: A E
Obs: the classes can extends one other one and implements any it wants

7. JDBC
My: C
Obs:Correct, rs.updateString(2,”Jack”) is ignored because commit operation is missing

8. Stream - Terminal Operation allMatch
My: A
Obs: correct, because the terminal operation allMatch runs once, because the first result is false the filter returns nothing.

9. Null Array
My: C
Obs: When the code runs a for with null value , the core throws in run time an exception

10. JDBC - connection creation
My: B
Obs: Incorrect, C is correct - The connection is created in try with resources. So is closed when try clause finishes.
Creating statement upon closed connection produces SQLException

11. Optional Nullable
My: A
ObS: Incorrect, The Nullable returns Optional empty case the object were null, Optional.of call thrpw an exeception when the varible passed is null

12. Try-Catch Resource - Order that the exception is called
My: B
ObS: incorrect, first print "Scanner" step throw when reach the exception the application will call the autoclose in reverse order so call, "Print close", "Scanner closed" and finally
will go to the catch clause printing the main exception "Unable to scan"

13. JDBC create query
My: D
Obs: Correct, the code create correctly a query.

========================================================================== FROM SITE ===============================================================================================
corrects: 8/85
wrongs: 2/85
1. Exceptions hieritance
My: B
Obs: We can throws the super exception and child exception on some time.

2. Stream - Terminal Operation allMatch (Some 8 question from the book)
My: A
Obs: correct, because the terminal operation allMatch runs once, because the first result is false the filter returns nothing.

3. NIO 2 -  Path resolve() method
My: C
Obs: correct, because when the path passed as parameter to resolver were absolute, so the first path is ignored and the
resolver() does not remove simbols like ../  ou ./

4. ZoneDateTime
My: A
Obs: correct, because for calc the negative number increase time, por example GMT-7 , increase seven our for the current time.

5. Extends private method
My: C
Obs: incorrect, when we declare a method ith some signature that the super private method it is allowed, but when we try do this
with final method even if it is private, a compile error occurs, in this questions the compile erro is on the test class
because read() from super is private.

6. IO - BufferedReader
My: D
Obs: correct, because then the ready is called an exception is throw because the stream is closed and before this the file's content is showed.

7. Stream and FlatMap
My: A
Obs: correct, because it is necessary join the lists to print the sequence, for this we can use flatMap with Steam.of(l1, l2).flatMap(list -> list.stream())

8. Interface Implementation
My A E
Obs: A is correct because the abstract class is not required to implement the super methods, E is correct because the class implements correctly the super method
and overload this method correctly.

9. Path - move() - ATOMIC
My: B
Obs:correct, ATOMIC_MOVE , can move the file even if the file exists and the file will be overwrite its content, case if not atomic, a error could be throws
FileExistsException

10. Stream foreach order
My: A
Obs: incorrect, the correct answer is B, because the answer A will print the object hash because the class didn't implement the toString, the B answer user the map
to show the value.

11. Arrays sort
My: A
Obs:The sort method of the Arrays class can sort incoming arrays, and can also pass in a Comparator to determine the array sorting method.
The checkValue method of the CheckClass class is a category method and can be used without materialization

12.